<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lec 9 Fraud-ML-2 - Interactive Learning</title>
    
    <!-- KaTeX for formula rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    
    <!-- Mermaid for flowcharts and diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    
    <!-- Fonts: Noto Serif for body, Inter for headings -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        
        :root {
            /* Warm Academic Theme - Clean & Readable */
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #1f2b47;
            --bg-elevated: #263352;
            --bg-card: #1c2a45;
            
            --text-primary: #edf2f7;
            --text-secondary: #a0aec0;
            --text-tertiary: #718096;
            
            /* Warm Gold + Sage Green palette */
            --accent-primary: #f6c177;
            --accent-secondary: #a3d9a5;
            --accent-tertiary: #c4b5fd;
            --accent-warning: #fbbf24;
            --accent-error: #fb7185;
            --accent-info: #7dd3fc;
            
            --gradient-primary: linear-gradient(135deg, #f6c177 0%, #e8a87c 100%);
            --gradient-heading: linear-gradient(135deg, #f6c177 0%, #c4b5fd 100%);
            
            --border-color: rgba(255, 255, 255, 0.06);
            --border-hover: rgba(246, 193, 119, 0.25);
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.25);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.4);
            
            --font-body: 'Georgia', 'Times New Roman', 'Noto Serif SC', serif;
            --font-heading: -apple-system, 'Helvetica Neue', 'PingFang SC', sans-serif;
            --font-mono: 'SF Mono', 'Menlo', 'Monaco', monospace;
            
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            
            --ease: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @media (prefers-color-scheme: light) {
            :root {
                --bg-primary: #faf8f5;
                --bg-secondary: #f0ece4;
                --bg-tertiary: #e8e2d8;
                --bg-elevated: #ffffff;
                --bg-card: #ffffff;
                
                --text-primary: #1c1917;
                --text-secondary: #57534e;
                --text-tertiary: #a8a29e;
                
                --accent-primary: #c2742f;
                --accent-secondary: #3d8b40;
                --accent-tertiary: #7c3aed;
                --accent-warning: #b45309;
                --accent-error: #dc2626;
                
                --gradient-heading: linear-gradient(135deg, #c2742f 0%, #7c3aed 100%);
                
                --border-color: rgba(0, 0, 0, 0.06);
                --border-hover: rgba(194, 116, 47, 0.3);
                --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.06);
                --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
                --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
            }
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            scroll-behavior: smooth;
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            overflow-x: hidden;
        }
        
        .page-container {
            --left-width: 260px;
            --right-width: 300px;
            display: grid;
            grid-template-columns: minmax(200px, var(--left-width)) 8px minmax(0, 1fr) 8px minmax(220px, var(--right-width));
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .column-resizer {
            cursor: col-resize;
            background: transparent;
            transition: background-color 0.15s var(--ease);
            position: sticky;
            top: 0;
            height: 100vh;
            z-index: 5;
        }
        .column-resizer:hover,
        .column-resizer.dragging {
            background: rgba(246, 193, 119, 0.2);
        }
        
        .sidebar-left, .sidebar-right {
            background: var(--bg-secondary);
            padding: 2rem 1.25rem;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
        }
        
        .sidebar-left {
            border-right: 1px solid var(--border-color);
        }
        
        .sidebar-right {
            border-left: 1px solid var(--border-color);
        }
        
        .main-content {
            max-width: none;
            min-width: 0;
            width: 100%;
            margin: 0 auto;
            padding: 3rem 2.5rem;
        }
        
        @media (max-width: 1200px) {
            .page-container { grid-template-columns: 1fr; }
            .sidebar-left, .sidebar-right, .column-resizer { display: none; }
            .main-content { padding: 2rem 1.25rem; }
        }
        
        h1 {
            font-family: var(--font-heading);
            font-size: clamp(1.875rem, 4vw, 2.5rem);
            font-weight: 700;
            line-height: 1.2;
            margin-bottom: 0.75rem;
            letter-spacing: -0.01em;
            color: var(--text-primary);
        }
        
        h2 {
            font-family: var(--font-heading);
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 3.5rem;
            margin-bottom: 1.25rem;
            color: var(--accent-primary);
            letter-spacing: -0.01em;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        h3 {
            font-family: var(--font-heading);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
        
        h4 {
            font-family: var(--font-heading);
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        
        h5 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-size: 1rem;
            line-height: 1.8;
        }
        
        .feynman-block {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--accent-primary);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            margin: 1.5rem 0;
            transition: border-color 0.2s var(--ease);
        }
        
        .feynman-block:hover {
            border-color: var(--border-hover);
        }
        
        .feynman-block .icon {
            font-size: 1.75rem;
            margin-bottom: 0.75rem;
            display: inline-block;
        }
        
        .expandable {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            margin: 1.5rem 0;
            overflow: hidden;
        }
        
        .expandable-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            cursor: pointer;
            user-select: none;
            font-weight: 500;
            font-family: var(--font-heading);
            transition: background 0.15s var(--ease);
        }
        
        .expandable-header:hover {
            background: var(--bg-tertiary);
        }
        
        .expandable-icon {
            transition: transform 0.25s var(--ease);
            display: inline-block;
            font-size: 0.8rem;
        }
        
        .expandable.open .expandable-icon {
            transform: rotate(180deg);
        }
        
        .expandable-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s var(--ease);
        }
        
        .expandable.open .expandable-content {
            max-height: 5000px;
        }
        
        .expandable-content-inner {
            padding: 1.25rem;
            border-top: 1px solid var(--border-color);
        }
        
        .quiz-container {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            margin: 2rem 0;
            border: 1px solid var(--border-color);
        }
        
        .quiz-question {
            font-size: 1.05rem;
            font-family: var(--font-heading);
            margin-bottom: 1.25rem;
            color: var(--text-primary);
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 0.625rem;
        }
        
        .quiz-option {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.15s var(--ease);
            font-size: 0.95rem;
        }
        
        .quiz-option:hover {
            border-color: var(--accent-primary);
            padding-left: 1.25rem;
        }
        
        .quiz-option.correct {
            background: rgba(163, 217, 165, 0.2);
            border-color: var(--accent-secondary);
            color: var(--accent-secondary);
        }
        
        .quiz-option.incorrect {
            background: rgba(251, 113, 133, 0.15);
            border-color: var(--accent-error);
            color: var(--accent-error);
        }
        
        .quiz-feedback {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            border-radius: var(--radius-sm);
            display: none;
            font-size: 0.9rem;
        }
        
        .quiz-feedback.show { display: block; }
        .quiz-feedback.correct { background: rgba(163, 217, 165, 0.15); border: 1px solid var(--accent-secondary); }
        .quiz-feedback.incorrect { background: rgba(251, 113, 133, 0.1); border: 1px solid var(--accent-error); }
        
        .progress-tracker {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--bg-secondary);
            z-index: 1000;
        }
        
        .progress-bar {
            height: 100%;
            background: var(--gradient-primary);
            width: 0%;
            transition: width 0.2s var(--ease);
        }
        
        .ai-chat {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 1.25rem;
        }
        
        .ai-chat-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .ai-chat-messages {
            max-height: 320px;
            overflow-y: auto;
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
        }
        
        .ai-message {
            margin-bottom: 0.75rem;
            padding: 0.625rem 0.875rem;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            line-height: 1.6;
        }
        
        .ai-message.user {
            background: var(--accent-primary);
            color: var(--bg-primary);
            margin-left: 1.5rem;
            font-weight: 500;
        }
        
        .ai-message.assistant {
            background: var(--bg-tertiary);
            margin-right: 1.5rem;
        }
        
        .ai-input-group { display: flex; gap: 0.5rem; }
        
        .ai-input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 0.625rem 0.75rem;
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 0.875rem;
        }
        
        .ai-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .ai-send-btn, .action-btn {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: var(--radius-sm);
            padding: 0.625rem 1rem;
            cursor: pointer;
            font-weight: 600;
            font-family: var(--font-heading);
            font-size: 0.85rem;
            transition: opacity 0.15s;
        }
        
        .action-btn {
            width: 100%;
            margin-bottom: 0.5rem;
            text-align: left;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .ai-send-btn:hover { opacity: 0.85; }
        .action-btn:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
        
        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.15rem 0.5rem;
            font-family: var(--font-mono);
            font-size: 0.8em;
        }
        
        .toc-link {
            color: var(--text-secondary);
            text-decoration: none;
            display: block;
            padding: 0.375rem 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-heading);
            transition: color 0.15s, background 0.15s;
        }
        
        .toc-link:hover {
            color: var(--accent-primary);
            background: var(--bg-tertiary);
        }
        
        /* Scroll reveal - simple fade */
        .reveal-on-scroll {
            opacity: 0;
            transform: translateY(16px);
            transition: opacity 0.5s var(--ease), transform 0.5s var(--ease);
        }
        .reveal-on-scroll.revealed {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--bg-elevated); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-tertiary); }
        
        ::selection { background: var(--accent-primary); color: var(--bg-primary); }
        
        /* Print */
        @media print {
            .sidebar-left, .sidebar-right, .progress-tracker { display: none; }
            .page-container { grid-template-columns: 1fr; }
            body { background: white; color: black; }
        }
        
        /* ===========================================
           DATA VISUALIZATION & CHARTS
           =========================================== */
        .chart-container {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            margin: 2rem 0;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }
        .chart-container .chart-title {
            font-family: var(--font-heading);
            font-size: 1.05rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            text-align: center;
        }
        .chart-container canvas { max-height: 380px; width: 100% !important; }
        .chart-caption {
            font-size: 0.85rem;
            color: var(--text-tertiary);
            text-align: center;
            margin-top: 0.75rem;
            font-style: italic;
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        .chart-grid .chart-container { margin: 0; }
        
        .diagram-container {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            margin: 2rem 0;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            overflow-x: auto;
            text-align: center;
        }
        .diagram-container .diagram-title {
            font-family: var(--font-heading);
            font-size: 1.05rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }
        .diagram-container .mermaid { display: flex; justify-content: center; }
        .diagram-container .mermaid svg { max-width: 100%; height: auto; }
        .diagram-caption {
            font-size: 0.85rem;
            color: var(--text-tertiary);
            text-align: center;
            margin-top: 0.75rem;
            font-style: italic;
        }
        
        .comparison-block {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 1rem;
            align-items: stretch;
            margin: 2rem 0;
        }
        .comparison-side {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }
        .comparison-side.left { border-top: 3px solid var(--accent-primary); }
        .comparison-side.right { border-top: 3px solid var(--accent-secondary); }
        .comparison-side h4 { margin-bottom: 0.75rem; }
        .comparison-side ul { padding-left: 1.25rem; }
        .comparison-side li { margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.95rem; }
        .comparison-divider {
            display: flex;
            align-items: center;
            font-size: 1.5rem;
            color: var(--text-tertiary);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        .stat-card {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 1.25rem;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: transform 0.15s var(--ease);
        }
        .stat-card:hover { transform: translateY(-3px); box-shadow: var(--shadow-lg); }
        .stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent-primary);
            display: block;
            font-family: var(--font-heading);
        }
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-tertiary);
            margin-top: 0.25rem;
        }
        
        @media (max-width: 768px) {
            .comparison-block { grid-template-columns: 1fr; }
            .comparison-divider { justify-content: center; padding: 0.5rem 0; }
            .chart-grid { grid-template-columns: 1fr; }
        }
        
        /* ===========================================
           SIDEBAR TABS & PANELS
           =========================================== */
        .sidebar-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 1rem;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            padding: 2px;
        }
        .sidebar-tab {
            flex: 1;
            padding: 0.5rem 0.25rem;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            font-family: var(--font-heading);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s var(--ease);
        }
        .sidebar-tab:hover { color: var(--text-secondary); }
        .sidebar-tab.active {
            background: var(--bg-elevated);
            color: var(--accent-primary);
        }
        
        /* ===========================================
           NOTES SYSTEM
           =========================================== */
        .note-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 0.625rem;
            font-size: 0.85rem;
            position: relative;
            cursor: pointer;
            transition: border-color 0.15s var(--ease), transform 0.15s var(--ease);
        }
        .note-card:hover { border-color: var(--border-hover); }
        .note-card.active {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }
        .note-card.focused {
            border-left: 3px solid var(--accent-secondary);
            padding-left: calc(0.625rem - 2px);
        }
        .note-card .note-citation {
            font-size: 0.75rem;
            color: var(--text-tertiary);
            border-left: 2px solid var(--accent-primary);
            padding-left: 0.5rem;
            margin-bottom: 0.375rem;
            font-style: italic;
            line-height: 1.4;
        }
        .note-card .note-body {
            color: var(--text-secondary);
            line-height: 1.5;
        }
        .note-card .note-meta {
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: 0.375rem;
            display: flex;
            justify-content: space-between;
        }
        .note-card .note-delete {
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 0;
        }
        .note-card .note-delete:hover { color: var(--accent-error); }
        .note-card .note-focus {
            background: none;
            border: none;
            color: var(--accent-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 0;
            margin-right: 0.5rem;
        }
        .note-card .note-focus:hover { color: var(--accent-primary); }
        .note-reader {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--bg-primary);
            overflow-y: auto;
            max-height: 34vh;
        }
        .note-reader .reader-title {
            font-size: 0.8rem;
            color: var(--text-tertiary);
            margin-bottom: 0.5rem;
        }
        .note-reader .reader-content {
            color: var(--text-secondary);
            line-height: 1.65;
            font-size: 0.9rem;
        }
        .note-reader .reader-content code {
            background: var(--bg-tertiary);
            padding: 0.1em 0.35em;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .note-draft-preview {
            margin-top: 0.5rem;
            max-height: 20vh;
        }
        
        /* ===========================================
           TEXT HIGHLIGHT
           =========================================== */
        .text-highlight {
            background: rgba(246, 193, 119, 0.25);
            border-bottom: 2px solid var(--accent-primary);
            cursor: pointer;
            transition: background 0.15s;
        }
        .text-highlight:hover {
            background: rgba(246, 193, 119, 0.4);
        }
        
        /* Highlight context menu */
        .highlight-tooltip {
            position: fixed;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-lg);
            padding: 0.25rem;
            display: none;
            z-index: 1001;
            gap: 2px;
        }
        .highlight-tooltip.show { display: flex; }
        .highlight-tooltip button {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 0.375rem 0.625rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: var(--font-heading);
            border-radius: 4px;
            white-space: nowrap;
        }
        .highlight-tooltip button:hover {
            background: var(--bg-tertiary);
            color: var(--accent-primary);
        }
    
    </style>
    <link rel="stylesheet" href="./app-shell.css?v=12" />
</head>
<body data-shell-page="lecture">
    <!-- Progress Tracker -->
    <div class="progress-tracker">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="page-container">
        <!-- Left Sidebar -->
        <aside class="sidebar-left">
            <!-- Sidebar Tabs -->
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" data-tab="toc" onclick="switchSidebarTab('toc')">Contents</button>
                <button class="sidebar-tab" data-tab="pdf" onclick="switchSidebarTab('pdf')">PDF</button>
                <button class="sidebar-tab" data-tab="notes" onclick="switchSidebarTab('notes')">Notes</button>
            </div>
            
            <!-- Tab: Table of Contents -->
            <div class="sidebar-panel" id="panel-toc">
                <ul style="list-style: none; padding: 0;">
                    <li style="margin-bottom: 0.75rem;">
                        <a href="#overview" class="toc-link">Overview</a>
                    </li>
                    
            <li style="margin-bottom: 0.75rem;">
                <a href="#concept-1" class="toc-link">Class Imbalance</a>
            </li>
        
            <li style="margin-bottom: 0.75rem;">
                <a href="#concept-2" class="toc-link">Decision Trees (DT)</a>
            </li>
        
            <li style="margin-bottom: 0.75rem;">
                <a href="#concept-3" class="toc-link">Gini Impurity</a>
            </li>
        
            <li style="margin-bottom: 0.75rem;">
                <a href="#concept-4" class="toc-link">Model Interpretability</a>
            </li>
        
            <li style="margin-bottom: 0.75rem;">
                <a href="#concept-5" class="toc-link">Evolution of Fraud Methodologies</a>
            </li>
        
            <li style="margin-bottom: 0.75rem;">
                <a href="#concept-6" class="toc-link">Feature Construction</a>
            </li>
        
                </ul>
                
                <div style="margin-top: 3rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.85rem;">
                    <div style="color: var(--text-tertiary); margin-bottom: 0.5rem;">Course Stats</div>
                    <div style="color: var(--text-secondary);">
                        <div>6 Concepts</div>
                        <div>15 Images</div>
                        <div>39 Tables</div>
                    </div>
                </div>
            </div>
            
            <!-- Tab: PDF Viewer -->
            <div class="sidebar-panel" id="panel-pdf" style="display:none;">
                <div id="pdfViewerContainer" style="height: calc(100vh - 80px); display: flex; flex-direction: column;">
                    <p style="font-size: 0.85rem; color: var(--text-tertiary); margin-bottom: 0.75rem;">Source: Lec 9 Fraud-ML-2.pdf</p>
                    <iframe id="pdfFrame" src="../pdfs/Lec 9 Fraud-ML-2.pdf" style="flex:1; width:100%; border:none; border-radius: var(--radius-sm); background: var(--bg-tertiary);"></iframe>
                </div>
            </div>
            
            <!-- Tab: Notes -->
            <div class="sidebar-panel" id="panel-notes" style="display:none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <span style="font-size: 0.85rem; color: var(--text-tertiary);" id="notesCount">0 notes</span>
                    <button onclick="exportNotesToObsidian()" class="action-btn" style="width:auto; padding: 0.4rem 0.75rem; font-size: 0.8rem;">Export .md</button>
                </div>
                <div id="notesList" style="display: flex; flex-direction: column; gap: 0.5rem; max-height: 32vh; overflow-y: auto;"></div>
                <div id="noteReader" class="note-reader">
                    <div class="reader-title">Reading</div>
                    <div class="reader-content">Click a note in history to read it here.</div>
                </div>
                <div style="margin-top: 0.75rem; border-top: 1px solid var(--border-color); padding-top: 0.75rem;">
                    <textarea id="noteInput" oninput="handleNoteInputChange(this.value)" placeholder="Write a note (Markdown supported)..." style="width:100%; min-height: 80px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: var(--radius-sm); padding: 0.5rem; color: var(--text-primary); font-family: var(--font-mono); font-size: 0.85rem; resize: vertical;"></textarea>
                    <div id="noteDraftPreview" class="note-reader note-draft-preview">
                        <div class="reader-title">Live Preview</div>
                        <div class="reader-content" id="noteDraftPreviewContent">Type in the note box to preview Markdown rendering in real time.</div>
                    </div>
                    <button onclick="addFreeNote()" class="action-btn" style="margin-top: 0.375rem;">Add Note</button>
                </div>
            </div>
        </aside>

        <div class="column-resizer" id="resizerLeft" role="separator" aria-orientation="vertical" aria-label="Resize left sidebar"></div>

        <!-- Main Content -->
        <main class="main-content">
            <header id="overview">
                <h1>Lec 9 Fraud-ML-2</h1>
                <p style="font-size: 1.1rem; color: var(--text-tertiary); margin-bottom: 2rem;">
                    Interactive Learning Experience • Source: Lec 9 Fraud-ML-2.pdf
                </p>
                
                <!-- Course Overview -->
                <div class="feynman-block" style="border-left-color: #9f7aea;">
                    <h4>Course Overview</h4>
                    <p><strong>Difficulty:</strong> Intermediate</p>
                    
                    <h5 style="margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--accent-primary);">Prerequisites:</h5>
                    <ul style="margin-left: 1.5rem;">
                        <li>Basic understanding of supervised machine learning and classification.</li><li>Fundamental knowledge of probability and statistics.</li><li>General awareness of financial transaction systems and insurance claims.</li><li>Familiarity with mathematical notation for summations and functions.</li>
                    </ul>
                    
                    <h5 style="margin-top: 1.5rem; margin-bottom: 0.5rem; color: var(--accent-secondary);">Learning Objectives:</h5>
                    <ul style="margin-left: 1.5rem;">
                        <li>Identify the unique challenges of applying machine learning to fraud detection, such as class imbalance and evolving patterns.</li><li>Explain the structural components and decision-making logic of a Decision Tree model.</li><li>Calculate the Gini Impurity to evaluate the quality of a split in a classification tree.</li><li>Compare the advantages and disadvantages of different generations of fraud detection methodologies.</li>
                    </ul>
                </div>
            </header>

            <!-- Concept Sections -->
            
        <section id="concept-1" class="concept-section">
            <h2>Class Imbalance</h2>
            
            <!-- Simple Analogy -->
            <div class="feynman-block" style="border-left-color: var(--accent-primary);">
                <h4>Simple Analogy</h4>
                <p>Imagine you are looking for a four-leaf clover in a massive field of three-leaf clovers. Because 99.9% of what you see is the common variety, your brain might start ignoring the small details and assume every plant is just a standard clover, making it nearly impossible to spot the rare one you actually care about.</p>
            </div>
            
            <!-- Why It Matters -->
            <div class="feynman-block" style="border-left-color: var(--accent-secondary);">
                <h4>Why This Matters</h4>
                <p>In fraud detection, failing to identify a single fraudulent transaction can result in massive financial loss or identity theft. If a model isn't specifically adjusted for class imbalance, it will simply learn to predict 'No Fraud' for every transaction to achieve a high accuracy score, leaving the system completely unprotected.</p>
            </div>
            
            <!-- Visualization -->
            
        <div class="chart-container">
            <div class="chart-title">Typical Data Distribution in Fraud Detection</div>
            <canvas id="chart-1" style="max-height:380px;"></canvas>
            <div class="chart-caption">The massive imbalance makes it easy for models to ignore the 'Fraud' class entirely.</div>
        </div>
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            const ctx = document.getElementById('chart-1');
            if (ctx && typeof Chart !== 'undefined') {
                new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: ["Legitimate Transactions (Majority Class)", "Fraudulent Transactions (Minority Class)"],
                        datasets: [{"label": "Transaction Volume", "data": [99.8, 0.2], "borderColor": "#ffffff", "backgroundColor": ["#4299e1", "#f56565"]}]
                    },
                    options: {
                        plugins: {
                            legend: { position: 'bottom' },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        
                    }
                });
            }
        });
        </script>
        
            
            <!-- Deep Explanation -->
            <div class="expandable">
                <div class="expandable-header">
                    <span>Deep Dive: Detailed Explanation</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Machine learning models are designed to minimize errors, but they treat all errors as equal by default. In an imbalanced dataset where 99% of transactions are legitimate, a model can reach 99% accuracy just by blindly guessing 'legitimate' every time; it essentially 'ignores' the fraud cases because they are statistically insignificant to its overall success rate. To solve this, we must use techniques like oversampling (duplicating fraud examples), undersampling (removing legitimate examples), or using different evaluation metrics like Precision and Recall instead of simple Accuracy to ensure the model focuses on the rare but critical events.</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.95rem; color: var(--text-tertiary);"><strong>From lecture:</strong><br>•  Changing fraud patterns over time. Fraudsters are always in the lookout to
find new and innovative ways to get around the system.

•  Class Imbalance. Practically only a small percentage of customers have
fraudulent intentions. Consequently, there’s an imbalance in the classification of fraud detection models (that usually classify transactions as either fraudulent or non-fraudulent) which makes it harder to build them.

•  Model Interpretation. The model typically give a score indicating whe</div>
                    </div>
                </div>
            </div>
            
            <!-- Practical Example -->
            <div class="expandable open">
                <div class="expandable-header">
                    <span>Practical Example</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>A bank processes 100,000 credit card transactions, and only 100 are actually fraudulent (0.1%). A model that predicts 'Legitimate' for all 100,000 transactions would be 99.9% accurate, but it would have a 0% success rate at stopping fraud. To fix this, the bank might 'oversample' those 100 fraud cases, showing them to the model thousands of times until it learns the specific patterns that distinguish them from the majority.</p>
                    </div>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="feynman-block" style="border-left-color: var(--accent-warning);">
                <h4>Common Mistakes</h4>
                <p>Students often celebrate when their model achieves 99% accuracy on a fraud dataset. In reality, accuracy is a 'vanity metric' in imbalanced data; you must check the Recall to see how many actual fraud cases you missed.</p>
            </div>
            
            <!-- Quiz Questions -->
            
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 1:</strong> In the context of fraud detection, why is class imbalance considered a major challenge?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Fraudulent transactions occur more frequently than legitimate ones.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Most customers have fraudulent intentions, making it hard to identify honest ones.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Practically only a small percentage of customers are fraudulent, leading to a lack of data for the minority class.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Models are unable to provide numerical scores for transaction analysis.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Class imbalance occurs because fraudulent transactions represent only a tiny fraction of total activity, making it difficult for models to learn the characteristics of fraud.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Class imbalance occurs because fraudulent transactions represent only a tiny fraction of total activity, making it difficult for models to learn the characteristics of fraud.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 2:</strong> How do changing fraud patterns affect the effectiveness of detection systems?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        They make feature construction less expensive over time.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Fraudsters constantly seek new and innovative ways to bypass existing systems, requiring models to adapt.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        They ensure that class imbalance is eventually eliminated.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        They provide models with more explanations for their classification scores.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! The dynamic nature of fraud means that systems must constantly evolve to counter new methods used by fraudsters to circumvent security measures.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. The dynamic nature of fraud means that systems must constantly evolve to counter new methods used by fraudsters to circumvent security measures.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 3:</strong> What is a significant limitation regarding model interpretation in fraud detection?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Models provide detailed explanations for every fraudulent transaction flagged.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Feature construction is automated and requires no manual intervention.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        The model typically provides a score indicating likelihood but offers no explanation for its decision.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Classification models can only identify transactions as fraudulent and never as non-fraudulent.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! A key issue in model interpretation is that detection systems often output a probability score without explaining the reasoning behind that specific classification.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. A key issue in model interpretation is that detection systems often output a probability score without explaining the reasoning behind that specific classification.
                    </div>
                </div>
                
        </section>
        
        <section id="concept-2" class="concept-section">
            <h2>Decision Trees (DT)</h2>
            
            <!-- Simple Analogy -->
            <div class="feynman-block" style="border-left-color: var(--accent-primary);">
                <h4>Simple Analogy</h4>
                <p>Think of a Decision Tree as a game of '20 Questions.' To guess an object, you ask specific yes-or-no questions like 'Is it alive?' or 'Can it fly?' to narrow down the possibilities until you reach a final answer.</p>
            </div>
            
            <!-- Why It Matters -->
            <div class="feynman-block" style="border-left-color: var(--accent-secondary);">
                <h4>Why This Matters</h4>
                <p>In fraud detection, Decision Trees provide a clear audit trail that explains exactly why a transaction was flagged. This 'interpretability' is essential for regulatory compliance and helps human investigators verify suspicious activity.</p>
            </div>
            
            <!-- Visualization -->
            
        <div class="diagram-container">
            <div class="diagram-title">Fraud Detection Decision Tree</div>
            <div class="mermaid">
flowchart TD
    A[Start: Transaction Received] --> B{Amount > $1000?}
    B -- No --> C[Legitimate]
    B -- Yes --> D{New Merchant?}
    D -- No --> E[Legitimate]
    D -- Yes --> F{International IP?}
    F -- No --> G[Manual Review]
    F -- Yes --> H[Fraud Alert]
            </div>
            <div class="diagram-caption">A simple logic flow showing how a transaction is classified based on specific rules.</div>
        </div>
        
            
            <!-- Deep Explanation -->
            <div class="expandable">
                <div class="expandable-header">
                    <span>Deep Dive: Detailed Explanation</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>A Decision Tree works by systematically splitting data into branches based on feature values. It starts at a root node and asks a binary question (e.g., 'Is the amount > $500?'), then splits the data into two paths based on the answer. The algorithm chooses splits that maximize the 'purity' of the resulting groups, aiming to isolate fraudulent cases from legitimate ones. This process continues recursively until the model reaches a 'leaf' node, which provides the final prediction or outcome.</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.95rem; color: var(--text-tertiary);"><strong>From lecture:</strong><br>A supervised learning algorithm that maps features to outcomes using a tree-like structure of nodes and branches based on binary decision rules.</div>
                    </div>
                </div>
            </div>
            
            <!-- Practical Example -->
            <div class="expandable open">
                <div class="expandable-header">
                    <span>Practical Example</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>A bank analyzes a transaction: First, it asks 'Is the IP address from a high-risk country?' If yes, it then asks 'Is the transaction amount 10x the user's average?' If both are true, the transaction is classified as 'Fraud.' If the IP is local, it might simply ask 'Is the CVV correct?' to classify it as 'Legitimate.'</p>
                    </div>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="feynman-block" style="border-left-color: var(--accent-warning);">
                <h4>Common Mistakes</h4>
                <p>Students often believe a deeper tree with more branches is always more accurate. In reality, a tree that is too deep often 'overfits,' meaning it memorizes the noise of the training data and loses its ability to generalize to new, unseen transactions.</p>
            </div>
            
            <!-- Quiz Questions -->
            
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 1:</strong> What does each internal node in a Decision Tree represent?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        A final outcome or category
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        A mathematical weight applied to all inputs
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        A test or decision rule based on a specific feature
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        A cluster of similar data points without labels
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Internal nodes represent decision rules or tests on features that split the data into branches based on specific conditions.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Internal nodes represent decision rules or tests on features that split the data into branches based on specific conditions.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 2:</strong> Decision Trees are classified as which type of machine learning algorithm?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Unsupervised learning
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Supervised learning
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Reinforcement learning
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Clustering algorithm
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Decision Trees are supervised learning algorithms because they are trained on labeled data to map features to known outcomes.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Decision Trees are supervised learning algorithms because they are trained on labeled data to map features to known outcomes.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 3:</strong> How does a Decision Tree navigate from the root node to a final outcome?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        By calculating the average of all features simultaneously
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        By randomly selecting branches until a leaf is reached
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        By following a sequence of binary decision rules through branches
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        By measuring the distance between the input and the cluster centroid
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! The algorithm reaches a conclusion by traversing branches based on binary 'true/false' logic at each node until it hits a leaf node representing the outcome.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. The algorithm reaches a conclusion by traversing branches based on binary 'true/false' logic at each node until it hits a leaf node representing the outcome.
                    </div>
                </div>
                
        </section>
        
        <section id="concept-3" class="concept-section">
            <h2>Gini Impurity</h2>
            
            <!-- Simple Analogy -->
            <div class="feynman-block" style="border-left-color: var(--accent-primary);">
                <h4>Simple Analogy</h4>
                <p>Imagine a sock drawer: if it contains only white socks, you can grab one in the dark and be 100% certain of the color (Gini = 0). If the drawer is a chaotic 50/50 mix of black and white socks, your chances of grabbing the wrong color are at their highest (Gini = 0.5).</p>
            </div>
            
            <!-- Why It Matters -->
            <div class="feynman-block" style="border-left-color: var(--accent-secondary);">
                <h4>Why This Matters</h4>
                <p>In fraud detection, Gini Impurity acts as a mathematical filter that helps the model find the most suspicious patterns. It allows the system to determine which specific features—like transaction size or location—best separate honest customers from potential thieves.</p>
            </div>
            
            <!-- Visualization -->
            
        <div class="diagram-container">
            <div class="diagram-title">Decision Tree Split and Purity Reduction</div>
            <div class="mermaid">
flowchart TD
    A[Root Node: 50% Fraud / 50% Safe
High Impurity: 0.5] --> B{Check: Is Amount > $500?}
    B -- Yes --> C[Left Node: 100% Fraud
Zero Impurity: 0.0]
    B -- No --> D[Right Node: 100% Safe
Zero Impurity: 0.0]
            </div>
            <div class="diagram-caption">The process of using a feature to move from a 'mixed' state to a 'pure' state.</div>
        </div>
        
            
            <!-- Deep Explanation -->
            <div class="expandable">
                <div class="expandable-header">
                    <span>Deep Dive: Detailed Explanation</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Gini Impurity measures the probability of misclassifying an item if you were to label it randomly based on the distribution of classes in a specific group. When a Decision Tree evaluates a potential split, it calculates the Gini score for the resulting groups to see how 'clean' they are. A score of 0 means the group is perfectly pure (contains only one class), while a score of 0.5 (in a two-class system) means the group is a perfect 50/50 split of confusion. The algorithm's goal is to minimize this score at every step, effectively 'unmixing' the data until it reaches clear, predictable categories.</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.95rem; color: var(--text-tertiary);"><strong>From lecture:</strong><br>A mathematical metric used to measure the 'purity' of a node; it determines how well a potential split separates different classes in a dataset.</div>
                    </div>
                </div>
            </div>
            
            <!-- Practical Example -->
            <div class="expandable open">
                <div class="expandable-header">
                    <span>Practical Example</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Suppose you have a group of 10 transactions: 5 are Fraud and 5 are Legitimate (Gini = 0.5). You test a split: 'Is the transaction from a new IP address?' This split creates two groups: Group A has 5 Fraud/0 Legitimate, and Group B has 0 Fraud/5 Legitimate. Both new groups now have a Gini Impurity of 0, meaning the 'IP address' feature perfectly separated the data.</p>
                    </div>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="feynman-block" style="border-left-color: var(--accent-warning);">
                <h4>Common Mistakes</h4>
                <p>Students often mistake a high Gini score for high accuracy, but it is actually a measure of disorder; a lower Gini score is always the goal because it indicates a more successful and 'pure' classification.</p>
            </div>
            
            <!-- Quiz Questions -->
            
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 1:</strong> In the context of decision trees, what is the primary purpose of calculating Gini Impurity?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        To measure the probability of a specific feature being selected
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        To determine how effectively a split separates different classes in a dataset
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        To calculate the total number of layers required in a neural network
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        To estimate the processing time required to train a model
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Gini Impurity is used to evaluate how well a potential split separates data into distinct classes, with lower values indicating better separation.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Gini Impurity is used to evaluate how well a potential split separates data into distinct classes, with lower values indicating better separation.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 2:</strong> What does a Gini Impurity value of 0 indicate about a specific node?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="true">
                        The node is perfectly 'pure,' meaning all data points belong to a single class
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The node is perfectly 'impure,' meaning classes are distributed equally
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The node contains no data points and should be removed
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The split has failed to provide any statistical significance
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! A Gini Impurity of 0 represents maximum purity, where every observation in the node belongs to the same category.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. A Gini Impurity of 0 represents maximum purity, where every observation in the node belongs to the same category.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 3:</strong> When a decision tree algorithm compares two potential splits, which one is it more likely to choose?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        The split that results in a higher Gini Impurity
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The split that creates the most balanced number of samples
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        The split that results in a lower Gini Impurity
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The split that uses the most complex mathematical features
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Decision trees seek to minimize impurity at each step, so the split with the lowest Gini Impurity is preferred because it creates more homogeneous groups.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Decision trees seek to minimize impurity at each step, so the split with the lowest Gini Impurity is preferred because it creates more homogeneous groups.
                    </div>
                </div>
                
        </section>
        
        <section id="concept-4" class="concept-section">
            <h2>Model Interpretability</h2>
            
            <!-- Simple Analogy -->
            <div class="feynman-block" style="border-left-color: var(--accent-primary);">
                <h4>Simple Analogy</h4>
                <p>Think of a chef following a printed recipe versus a 'magic pot' that cooks a meal. With the recipe (interpretable), you can see exactly how much salt was added and why it tastes salty; with the magic pot (black-box), you get a delicious meal but have no idea what ingredients were used or why.</p>
            </div>
            
            <!-- Why It Matters -->
            <div class="feynman-block" style="border-left-color: var(--accent-secondary);">
                <h4>Why This Matters</h4>
                <p>In fraud detection, interpretability is crucial for legal compliance and customer trust because banks must be able to justify why they blocked a specific transaction. It also helps developers identify 'algorithmic bias,' ensuring the model isn't unfairly targeting specific groups based on irrelevant or illegal factors.</p>
            </div>
            
            <!-- Visualization -->
            
        <div class="comparison-block">
            <div class="comparison-side left">
                <h4>🔵 Interpretable (e.g., Decision Tree)</h4>
                <ul><li>Follows clear 'If-Then' logic pathways</li><li>Easy to explain to customers and regulators</li><li>Simple to audit for fairness and bias</li><li>Easier to debug when the model makes a mistake</li></ul>
            </div>
            <div class="comparison-divider">vs</div>
            <div class="comparison-side right">
                <h4>🟢 Black-Box (e.g., Deep Learning)</h4>
                <ul><li>Uses complex, multi-layered math (Neural Nets)</li><li>Extremely difficult for humans to trace logic</li><li>Provides a result without a 'reason'</li><li>Often more accurate at spotting hidden patterns</li></ul>
            </div>
        </div>
        
            
            <!-- Deep Explanation -->
            <div class="expandable">
                <div class="expandable-header">
                    <span>Deep Dive: Detailed Explanation</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Interpretability refers to how easily a human can understand the 'reasoning' behind an algorithm's output. Some models are inherently transparent because they use a series of logical 'if-then' rules, similar to a flow chart, where every step can be traced from input to result. Other models, specifically deep learning neural networks, process data through thousands of interconnected layers and mathematical weights, making it nearly impossible to pinpoint which specific feature caused a specific prediction. While these complex models often achieve higher accuracy by finding subtle patterns, the lack of interpretability makes it difficult to debug errors or prove to regulators that the model is making decisions based on valid, non-discriminatory logic.</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.95rem; color: var(--text-tertiary);"><strong>From lecture:</strong><br>The ability to explain the logic behind a model's prediction, which is a key advantage of Decision Trees compared to black-box algorithms like Neural Networks.</div>
                    </div>
                </div>
            </div>
            
            <!-- Practical Example -->
            <div class="expandable open">
                <div class="expandable-header">
                    <span>Practical Example</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>A Decision Tree flags a credit card transaction as fraud because the 'Purchase Amount > $500' AND 'Location = International' AND 'Time = 3:00 AM'. A human can look at this and immediately see the logic makes sense. Conversely, a Neural Network might give that same transaction a 99% fraud score, but when asked why, it can only point to millions of tiny numerical shifts across its layers, leaving the bank unable to explain the specific trigger to the customer.</p>
                    </div>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="feynman-block" style="border-left-color: var(--accent-warning);">
                <h4>Common Mistakes</h4>
                <p>Students often assume that a model's accuracy and its interpretability are the same thing, but in reality, there is usually a trade-off: the more complex and 'smart' a model becomes, the harder it usually is to explain its inner workings.</p>
            </div>
            
            <!-- Quiz Questions -->
            
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 1:</strong> What does 'model interpretability' primarily refer to in the context of machine learning?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        The speed at which a model can process a large dataset
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        The ability to explain the logic and reasoning behind a model's prediction
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The total memory capacity required to store the model parameters
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The percentage of correct predictions made on a test set
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Interpretability is the degree to which a human can understand the cause of a decision or prediction made by a model.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Interpretability is the degree to which a human can understand the cause of a decision or prediction made by a model.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 2:</strong> Why are Decision Trees often preferred over Neural Networks in industries like healthcare or finance?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Decision Trees are always more accurate than Neural Networks
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Neural Networks are easier to visualize as flowcharts
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Decision Trees provide a clear, rule-based path for predictions, making them 'white-box' models
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Decision Trees require significantly more computing power to interpret
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Decision Trees are considered interpretable because their hierarchical structure allows users to trace the exact logic used to reach an outcome.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Decision Trees are considered interpretable because their hierarchical structure allows users to trace the exact logic used to reach an outcome.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 3:</strong> Which term is commonly used to describe models like Deep Neural Networks because their internal decision-making process is difficult for humans to trace?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Transparent models
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        White-box algorithms
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Linear estimators
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Black-box algorithms
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Neural Networks are often called 'black-box' algorithms because their complex mathematical layers make it hard to explain exactly how they arrive at a specific result.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Neural Networks are often called 'black-box' algorithms because their complex mathematical layers make it hard to explain exactly how they arrive at a specific result.
                    </div>
                </div>
                
        </section>
        
        <section id="concept-5" class="concept-section">
            <h2>Evolution of Fraud Methodologies</h2>
            
            <!-- Simple Analogy -->
            <div class="feynman-block" style="border-left-color: var(--accent-primary);">
                <h4>Simple Analogy</h4>
                <p>Think of catching a thief: first, you gave guards a list of specific 'bad' behaviors (Rules); then, you gave them a math formula to calculate a risk score (Logistic Regression); finally, you hired a committee of 100 diverse experts to vote on every case (Random Forests).</p>
            </div>
            
            <!-- Why It Matters -->
            <div class="feynman-block" style="border-left-color: var(--accent-secondary);">
                <h4>Why This Matters</h4>
                <p>Fraudsters constantly change their tactics to bypass static security measures, costing the global economy billions annually. Moving toward ensemble methods like Random Forests allows banks to detect subtle, multi-layered criminal patterns that traditional systems simply cannot see.</p>
            </div>
            
            <!-- Visualization -->
            
        <div class="diagram-container">
            <div class="diagram-title">Evolution of Fraud Detection Complexity</div>
            <div class="mermaid">
flowchart LR
    A[Rule-Based Systems] -->|Rigid Logic| B(Logistic Regression)
    B -->|Statistical Weighting| C(Random Forests)
    C -->|Collective Intelligence| D{Ensemble Methods}
    style A fill:#f9f,stroke:#333
    style D fill:#4299e1,stroke:#333
            </div>
            <div class="diagram-caption">The transition from rigid, manual rules to decentralized, automated 'voting' models.</div>
        </div>
        
            
            <!-- Deep Explanation -->
            <div class="expandable">
                <div class="expandable-header">
                    <span>Deep Dive: Detailed Explanation</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>The evolution of fraud methodology represents a shift from human-defined logic to data-driven intelligence. Rule-based systems were 'expert systems' that relied on rigid IF-THEN statements, which were easy for criminals to learn and circumvent. Logistic Regression introduced statistical probability, allowing us to weigh different risk factors (like location or amount) simultaneously. Modern Random Forests and Ensemble methods take this further by training hundreds of individual 'decision trees' on different subsets of data; by aggregating their 'votes,' the system becomes incredibly resilient to noise and capable of identifying complex, non-linear relationships that a single model would miss.</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.95rem; color: var(--text-tertiary);"><strong>From lecture:</strong><br>The historical progression of fraud detection from rule-based expert systems to logistic regression, and currently to Random Forests and ensemble methods.</div>
                    </div>
                </div>
            </div>
            
            <!-- Practical Example -->
            <div class="expandable open">
                <div class="expandable-header">
                    <span>Practical Example</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Imagine a $10 transaction at a gas station. A rule-based system ignores it because it's a small amount. Logistic regression might flag it as slightly suspicious if it's in a new city. A Random Forest ensemble, however, analyzes the time of day, device ID, and recent small 'test' purchases across 100 different trees, correctly identifying it as a 'card-testing' fraud attempt that predecessors would have ignored.</p>
                    </div>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="feynman-block" style="border-left-color: var(--accent-warning);">
                <h4>Common Mistakes</h4>
                <p>Students often assume that newer models are better simply because they use more complex math. In reality, Random Forests excel because they use 'bagging' to reduce variance—meaning they prevent the system from overreacting to one weird transaction while missing the bigger picture.</p>
            </div>
            
            <!-- Quiz Questions -->
            
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 1:</strong> What was the primary characteristic of the earliest stage in the evolution of fraud detection methodologies?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Automated deep learning algorithms
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Manual rule-based expert systems
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Predictive ensemble modeling
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Probabilistic logistic regression
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! The earliest fraud detection systems relied on static, 'if-then' rules manually defined by human experts to identify suspicious patterns.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. The earliest fraud detection systems relied on static, 'if-then' rules manually defined by human experts to identify suspicious patterns.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 2:</strong> Which methodology represented the transition from rigid human-defined rules to statistical predictive modeling?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Random Forests
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        XGBoost
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Logistic Regression
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Expert Systems
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Logistic regression introduced a statistical approach that allowed systems to calculate the probability of fraud based on historical data rather than just binary rules.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Logistic regression introduced a statistical approach that allowed systems to calculate the probability of fraud based on historical data rather than just binary rules.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 3:</strong> In the current landscape of fraud detection, why are ensemble methods like Random Forests favored over older techniques?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        They are easier to document for regulatory compliance than rules.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        They require significantly less computing power than logistic regression.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        They rely on a single decision tree to ensure maximum simplicity.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        They can capture complex, non-linear relationships and high-dimensional data interactions.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Modern ensemble methods combine multiple models to detect sophisticated fraud patterns that linear models and simple rules often fail to catch.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Modern ensemble methods combine multiple models to detect sophisticated fraud patterns that linear models and simple rules often fail to catch.
                    </div>
                </div>
                
        </section>
        
        <section id="concept-6" class="concept-section">
            <h2>Feature Construction</h2>
            
            <!-- Simple Analogy -->
            <div class="feynman-block" style="border-left-color: var(--accent-primary);">
                <h4>Simple Analogy</h4>
                <p>Think of a chef preparing a meal: raw ingredients like flour, water, and yeast are your 'raw data,' but they don't taste like bread on their own. Feature construction is the process of kneading and fermenting them into 'dough,' a new state that the oven (your model) can actually transform into a finished product.</p>
            </div>
            
            <!-- Why It Matters -->
            <div class="feynman-block" style="border-left-color: var(--accent-secondary);">
                <h4>Why This Matters</h4>
                <p>In fraud detection, raw data like a 'timestamp' is nearly useless until it is constructed into a feature like 'number of transactions in the last hour.' This allows banks to catch high-frequency attacks that would otherwise look like individual, legitimate purchases.</p>
            </div>
            
            <!-- Visualization -->
            
        <div class="diagram-container">
            <div class="diagram-title">The Feature Construction Workflow</div>
            <div class="mermaid">
flowchart LR
    A[Raw Data: Timestamp, Amount, Lat/Long] --> B{Domain Expertise}
    B --> C[Feature Construction]
    C --> D[New Feature: Transactions per Hour]
    C --> E[New Feature: Distance from Home]
    D --> F[ML Model Decision]
    E --> F
    F --> G[Improved Fraud Detection]
            </div>
            <div class="diagram-caption">How raw data is transformed into actionable intelligence for fraud models.</div>
        </div>
        
            
            <!-- Deep Explanation -->
            <div class="expandable">
                <div class="expandable-header">
                    <span>Deep Dive: Detailed Explanation</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Feature construction is the process of using domain expertise to transform raw data into new, more meaningful variables that highlight the underlying patterns of a problem. Instead of forcing a machine learning model to find needles in a haystack of raw numbers, we create specific 'indicators'—such as the ratio of a transaction amount to the user's average spending—to make the fraud obvious. Although this manual process is labor-intensive and costly because it requires human experts to analyze criminal behavior, it is the primary way we make 'black box' models interpretable and highly accurate.</p>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.95rem; color: var(--text-tertiary);"><strong>From lecture:</strong><br>•  Model Interpretation. The model typically give a score indicating whether
the transaction is likely to be fraudulent or not, without any explanations.

•  Feature construction. Manually construct the features can be time and
financially costly. 5


[Tables on this page: 1]

============================================================
PAGE 7
============================================================
</div>
                    </div>
                </div>
            </div>
            
            <!-- Practical Example -->
            <div class="expandable open">
                <div class="expandable-header">
                    <span>Practical Example</span>
                    <span class="expandable-icon">▼</span>
                </div>
                <div class="expandable-content">
                    <div class="expandable-content-inner">
                        <p>Imagine a dataset with 'Transaction Time' and 'Merchant Location.' A human expert constructs a feature called 'Impossible Velocity' by calculating the distance between the current transaction and the previous one. If a card is used in Paris and then in Tokyo 20 minutes later, this constructed feature flags the 'Impossible Velocity' as 1 (True), making the fraud instantly detectable to even a simple model.</p>
                    </div>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="feynman-block" style="border-left-color: var(--accent-warning);">
                <h4>Common Mistakes</h4>
                <p>Students often believe that simply feeding more raw data into a complex model is better than constructing features, but raw data often lacks the context necessary for a model to learn efficiently.</p>
            </div>
            
            <!-- Quiz Questions -->
            
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 1:</strong> According to the provided text, what is a significant drawback of manual feature construction?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        It makes the model too simple to interpret.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        It requires very little domain knowledge.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        It can be time-consuming and financially expensive.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        It automatically generates explanations for transactions.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! The content explicitly states that manually constructing features can be both time and financially costly.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. The content explicitly states that manually constructing features can be both time and financially costly.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 2:</strong> When a model provides a score indicating if a transaction is likely to be fraudulent, what is typically missing?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        The numerical score itself.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        Explanations for the score.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The classification of the transaction.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        The financial cost of the transaction.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! The text notes that model interpretation is limited because scores are typically given without any accompanying explanations.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. The text notes that model interpretation is limited because scores are typically given without any accompanying explanations.
                    </div>
                </div>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <strong>Question 3:</strong> Which of the following best describes the challenge of model interpretation mentioned in the text?
                    </div>
                    <div class="quiz-options">
                        
                    <div class="quiz-option" data-correct="false">
                        Models are too expensive to run for fraud detection.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Feature construction is done automatically by the model.
                    </div>
                    
                    <div class="quiz-option" data-correct="true">
                        The model provides a score but lacks transparency on how it reached that conclusion.
                    </div>
                    
                    <div class="quiz-option" data-correct="false">
                        Manually constructed features are the only way to get an explanation.
                    </div>
                    
                    </div>
                    <div class="quiz-feedback correct">
                        ✓ Correct! Model interpretation is described as a challenge because models typically yield a score without explaining whether a transaction is fraudulent or not.
                    </div>
                    <div class="quiz-feedback incorrect">
                        ✗ Not quite. Model interpretation is described as a challenge because models typically yield a score without explaining whether a transaction is fraudulent or not.
                    </div>
                </div>
                
        </section>
        
            
            <!-- Completion -->
            <div style="margin-top: 4rem; padding: 2rem; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); border-radius: 12px; text-align: center; color: white;">
                <h3 style="margin-bottom: 1rem;">Course Complete!</h3>
                <p>You've reviewed all 6 main concepts. Keep practicing with the quizzes above.</p>
            </div>
        </main>

        <div class="column-resizer" id="resizerRight" role="separator" aria-orientation="vertical" aria-label="Resize right sidebar"></div>

        <!-- Right Sidebar: AI Assistant & Tools -->
        <aside class="sidebar-right">
            <div class="ai-chat">
                <div class="ai-chat-header">
                    <div>
                        <h3 style="margin: 0;">AI Study Assistant</h3>
                        <p style="font-size: 0.8rem; color: var(--text-tertiary); margin: 0;">Powered by Gemini</p>
                    </div>
                </div>
                
                <div class="ai-chat-messages" id="aiMessages">
                    <div class="ai-message assistant">
                        Hi! I'm your AI study assistant. Ask me anything about this topic, or request:
                        <ul style="margin-top: 0.5rem; padding-left: 1.5rem; font-size: 0.9rem;">
                            <li>Explanations in simpler terms</li>
                            <li>More examples</li>
                            <li>Practice questions</li>
                            <li>Connections to other concepts</li>
                        </ul>
                    </div>
                </div>
                
                <div class="ai-input-group">
                    <input 
                        type="text" 
                        class="ai-input" 
                        id="aiInput" 
                        placeholder="Ask a question..."
                        onkeypress="if(event.key==='Enter') sendAIMessage()"
                    />
                    <button class="ai-send-btn" onclick="sendAIMessage()">Send</button>
                </div>
            </div>

            <!-- Quick Actions -->
            <div style="margin-top: 2rem;">
                <h4 style="margin-bottom: 1rem; color: var(--text-tertiary);">Quick Actions</h4>
                <button onclick="reviewAllQuizzes()" class="action-btn">
                    Review All Quizzes
                </button>
                <button onclick="createSummary()" class="action-btn">
                    Generate Summary
                </button>
                <button onclick="window.print()" class="action-btn">
                    Print Notes
                </button>
            </div>
            
            <!-- Keyboard Shortcuts -->
            <div style="margin-top: 2rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; font-size: 0.85rem;">
                <h5 style="margin-bottom: 0.75rem; color: var(--text-tertiary);">Shortcuts</h5>
                <div id="shortcutsDisplay" style="color: var(--text-secondary); line-height: 1.8;">
                    <div><kbd id="shortcutFocusAI">Alt+A</kbd> Focus AI</div>
                    <div><kbd id="shortcutSummary">Alt+S</kbd> Summary</div>
                </div>
            </div>
        </aside>
    </div>

    <script>
        
        // ── Gemini Proxy Configuration ──
        const GEMINI_PROXY_URL = '../api/gemini';
        const LAYOUT_STORAGE_KEY = 'learning-layout-widths-v1';
        
        let courseContext = '';
        let conversationHistory = [];

        function escapeHtml(value) {
            return String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        // ── Main Controller ──
        class LearningPageController {
            constructor() {
                this.isMac = /Mac|iPhone|iPod|iPad/i.test(navigator.platform);
                this.setupExpandables();
                this.setupQuizzes();
                this.setupProgressTracking();
                this.setupScrollReveal();
                this.setupCourseContext();
                this.setupKeyboardShortcuts();
                this.initializeMermaid();
                this.initializeCharts();
                this.updateShortcutsDisplay();
                this.setupColumnResizers();
            }
            
            initializeMermaid() {
                if (typeof mermaid !== 'undefined') {
                    mermaid.initialize({
                        startOnLoad: true,
                        theme: 'dark',
                        themeVariables: {
                            primaryColor: '#263352',
                            primaryTextColor: '#edf2f7',
                            primaryBorderColor: '#f6c177',
                            lineColor: '#a0aec0',
                            secondaryColor: '#1f2b47',
                            tertiaryColor: '#1c2a45',
                            background: '#16213e',
                            mainBkg: '#263352',
                            nodeBorder: '#f6c177',
                            clusterBkg: '#1f2b47',
                            fontSize: '14px'
                        },
                        flowchart: { curve: 'basis', padding: 20 },
                        sequence: { actorMargin: 50 }
                    });
                }
            }
            
            initializeCharts() {
                if (typeof Chart !== 'undefined') {
                    Chart.defaults.color = '#a0aec0';
                    Chart.defaults.borderColor = 'rgba(255,255,255,0.06)';
                    Chart.defaults.font.family = "-apple-system, 'Helvetica Neue', sans-serif";
                    Chart.defaults.responsive = true;
                    Chart.defaults.maintainAspectRatio = true;
                    Chart.defaults.plugins.legend.labels.usePointStyle = true;
                }
            }
            
            setupCourseContext() {
                const mc = document.querySelector('.main-content');
                if (mc) courseContext = mc.innerText.substring(0, 6000);
            }
            
            setupExpandables() {
                document.querySelectorAll('.expandable-header').forEach(header => {
                    header.addEventListener('click', () => {
                        header.parentElement.classList.toggle('open');
                    });
                });
            }
            
            setupQuizzes() {
                document.querySelectorAll('.quiz-option').forEach(opt => {
                    opt.addEventListener('click', () => this.handleQuiz(opt));
                });
            }

            handleQuiz(option) {
                const quiz = option.closest('.quiz-container');
                const isCorrect = option.dataset.correct === 'true';
                
                quiz.querySelectorAll('.quiz-option').forEach(o => {
                    o.classList.remove('selected','correct','incorrect');
                });
                
                option.classList.add('selected');
                option.classList.add(isCorrect ? 'correct' : 'incorrect');
                
                if (!isCorrect) {
                    quiz.querySelectorAll('.quiz-option').forEach(o => {
                        if (o.dataset.correct === 'true') o.classList.add('correct');
                    });
                }
                
                const cf = quiz.querySelector('.quiz-feedback.correct');
                const ic = quiz.querySelector('.quiz-feedback.incorrect');
                if (isCorrect) { cf.classList.add('show'); ic.classList.remove('show'); }
                else { ic.classList.add('show'); cf.classList.remove('show'); }
            }

            
            setupProgressTracking() {
                window.addEventListener('scroll', () => {
                    const h = document.documentElement.scrollHeight - window.innerHeight;
                    const p = h > 0 ? Math.min((window.scrollY / h) * 100, 100) : 0;
                    document.getElementById('progressBar').style.width = p + '%';
                });
            }
            
            setupScrollReveal() {
                const obs = new IntersectionObserver((entries) => {
                    entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('revealed'); });
                }, { threshold: 0.08 });
                document.querySelectorAll('.reveal-on-scroll').forEach(el => obs.observe(el));
            }
            
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.altKey && e.key === 'a') {
                        e.preventDefault();
                        document.getElementById('aiInput')?.focus();
                    }
                    if (e.altKey && e.key === 's') {
                        e.preventDefault();
                        askSummary();
                    }
                });
            }
            
            updateShortcutsDisplay() {
                const prefix = this.isMac ? '⌥' : 'Alt+';
                const focusEl = document.getElementById('shortcutFocusAI');
                const summaryEl = document.getElementById('shortcutSummary');
                if (focusEl) focusEl.textContent = prefix + 'A';
                if (summaryEl) summaryEl.textContent = prefix + 'S';
            }

            setupColumnResizers() {
                if (window.matchMedia('(max-width: 1200px)').matches) return;
                const container = document.querySelector('.page-container');
                const leftResizer = document.getElementById('resizerLeft');
                const rightResizer = document.getElementById('resizerRight');
                if (!container || !leftResizer || !rightResizer) return;

                const minLeft = 200, maxLeft = 560;
                const minRight = 220, maxRight = 560;
                const minMain = 520;
                let leftWidth = 260;
                let rightWidth = 300;

                const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
                const applyWidths = () => {
                    container.style.setProperty('--left-width', leftWidth + 'px');
                    container.style.setProperty('--right-width', rightWidth + 'px');
                };
                const getTotalWidth = () => container.getBoundingClientRect().width - 16;
                const clampAll = () => {
                    const total = getTotalWidth();
                    leftWidth = clamp(leftWidth, minLeft, maxLeft);
                    rightWidth = clamp(rightWidth, minRight, maxRight);
                    if (total - leftWidth - rightWidth < minMain) {
                        const overflow = minMain - (total - leftWidth - rightWidth);
                        leftWidth = clamp(leftWidth - overflow / 2, minLeft, maxLeft);
                        rightWidth = clamp(rightWidth - overflow / 2, minRight, maxRight);
                        if (total - leftWidth - rightWidth < minMain) {
                            const rightCap = clamp(total - leftWidth - minMain, minRight, maxRight);
                            rightWidth = rightCap;
                            leftWidth = clamp(total - rightWidth - minMain, minLeft, maxLeft);
                        }
                    }
                };

                try {
                    const cached = JSON.parse(localStorage.getItem(LAYOUT_STORAGE_KEY) || '{}');
                    if (Number.isFinite(cached.left)) leftWidth = cached.left;
                    if (Number.isFinite(cached.right)) rightWidth = cached.right;
                } catch {}
                clampAll();
                applyWidths();

                const startDrag = (side) => (evt) => {
                    evt.preventDefault();
                    const rect = container.getBoundingClientRect();
                    const total = getTotalWidth();
                    const onMove = (moveEvt) => {
                        if (side === 'left') {
                            const rawLeft = moveEvt.clientX - rect.left;
                            const maxAllowed = Math.min(maxLeft, total - rightWidth - minMain);
                            leftWidth = clamp(rawLeft, minLeft, Math.max(minLeft, maxAllowed));
                        } else {
                            const rawRight = rect.right - moveEvt.clientX;
                            const maxAllowed = Math.min(maxRight, total - leftWidth - minMain);
                            rightWidth = clamp(rawRight, minRight, Math.max(minRight, maxAllowed));
                        }
                        applyWidths();
                    };
                    const stopMove = () => {
                        document.body.style.userSelect = '';
                        document.body.style.cursor = '';
                        leftResizer.classList.remove('dragging');
                        rightResizer.classList.remove('dragging');
                        localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify({ left: leftWidth, right: rightWidth }));
                        document.removeEventListener('pointermove', onMove);
                        document.removeEventListener('pointerup', stopMove);
                    };
                    document.body.style.userSelect = 'none';
                    document.body.style.cursor = 'col-resize';
                    (side === 'left' ? leftResizer : rightResizer).classList.add('dragging');
                    document.addEventListener('pointermove', onMove);
                    document.addEventListener('pointerup', stopMove);
                };

                leftResizer.addEventListener('pointerdown', startDrag('left'));
                rightResizer.addEventListener('pointerdown', startDrag('right'));
                window.addEventListener('resize', () => {
                    if (window.matchMedia('(max-width: 1200px)').matches) return;
                    clampAll();
                    applyWidths();
                });
            }
        }
        
        // ── AI Chat (Real Gemini API) ──
        async function sendAIMessage() {
            const input = document.getElementById('aiInput');
            const msg = input.value.trim();
            if (!msg) return;
            
            appendMsg('user', msg);
            input.value = '';
            input.disabled = true;
            
            const typingEl = appendMsg('assistant', '<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span>');
            
            try {
                const answer = await callGemini(msg);
                typingEl.innerHTML = formatMd(answer);
            } catch (err) {
                const errMsg = err?.message || String(err);
                let hint = 'Check console for details.';
                if (window.location.protocol === 'file:' || errMsg.includes('Failed to fetch')) {
                    const current = window.location.pathname.split('/').pop();
                    hint = `Start local server: python3 serve.py --open html/${current} and ensure GEMINI_API_KEY exists in .env.local`;
                }
                typingEl.innerHTML = '⚠️ Error: ' + escapeHtml(errMsg) + '<br><small>' + escapeHtml(hint) + '</small>';
                console.error('Gemini API error:', err);
            } finally {
                input.disabled = false;
                input.focus();
            }
        }
        
        async function callGemini(userMessage) {
            if (window.location.protocol === 'file:') {
                throw new Error('This page is opened as file:// and cannot reach ../api/gemini');
            }

            const prompt = `You are a concise study assistant for this course.

Course content (excerpt):
${courseContext.substring(0, 3500)}

Previous conversation:
${conversationHistory.slice(-4).map(m => m.role + ': ' + m.content).join('\n')}

Student question: ${userMessage}

Instructions:
- Answer in 3-6 sentences, be direct and complete
- Always finish your sentences, never leave a thought incomplete
- Use the course content as reference
- If the question is in Chinese, answer in Chinese`;

            const res = await fetch(GEMINI_PROXY_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: prompt,
                    generationConfig: { temperature: 0.7, maxOutputTokens: 1024 }
                })
            });
            
            if (!res.ok) {
                const errText = await res.text();
                throw new Error(`API ${res.status}: ${errText.substring(0, 200)}`);
            }
            
            const data = await res.json();
            const candidate = data.candidates?.[0];
            const answer = candidate?.content?.parts?.[0]?.text;
            if (!answer) throw new Error('Empty response from API');
            
            // Check if response was truncated
            if (candidate?.finishReason === 'MAX_TOKENS') {
                conversationHistory.push({ role: 'user', content: userMessage }, { role: 'assistant', content: answer });
                return answer + '...\n\n_(Response was trimmed. Ask a follow-up for more detail.)_';
            }
            
            conversationHistory.push({ role: 'user', content: userMessage }, { role: 'assistant', content: answer });
            return answer;
        }
        
        function appendMsg(role, html) {
            const container = document.getElementById('aiMessages');
            const div = document.createElement('div');
            div.className = 'ai-message ' + role;
            div.innerHTML = html;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            return div;
        }
        
        function formatMd(text) {
            return text
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code style="background:var(--bg-tertiary);padding:0.1em 0.4em;border-radius:3px;font-size:0.9em;">$1</code>')
                .replace(/\n/g, '<br>');
        }
        
        function askSummary() {
            const input = document.getElementById('aiInput');
            input.value = 'Please summarize the key concepts of this lesson in bullet points.';
            sendAIMessage();
        }
        
        function reviewAllQuizzes() {
            const q = document.querySelector('.quiz-container');
            if (q) q.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        function createSummary() { askSummary(); }
        
        // ── Sidebar Tabs ──
        function switchSidebarTab(tabName) {
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.sidebar-panel').forEach(p => p.style.display = 'none');
            document.querySelector(`.sidebar-tab[data-tab="${tabName}"]`)?.classList.add('active');
            const panel = document.getElementById('panel-' + tabName);
            if (panel) panel.style.display = 'block';
        }
        
        // ── Notes System ──
        const NOTES_STORAGE_KEY = 'learning-notes-' + document.title;
        const NOTES_FOCUS_KEY = NOTES_STORAGE_KEY + '-focus';
        const NOTES_ACTIVE_KEY = NOTES_STORAGE_KEY + '-active';
        const NOTES_DRAFT_KEY = NOTES_STORAGE_KEY + '-draft';
        
        function loadNotes() {
            try {
                const raw = JSON.parse(localStorage.getItem(NOTES_STORAGE_KEY) || '[]');
                if (!Array.isArray(raw)) return [];
                return raw.map((n, idx) => {
                    const idNum = Number(n?.id);
                    return {
                        id: Number.isFinite(idNum) ? idNum : -(idx + 1),
                        citation: typeof n?.citation === 'string' ? n.citation : (typeof n?.quote === 'string' ? n.quote : ''),
                        body: typeof n?.body === 'string' ? n.body : (typeof n?.text === 'string' ? n.text : (typeof n?.content === 'string' ? n.content : '')),
                        section: typeof n?.section === 'string' ? n.section : (typeof n?.title === 'string' ? n.title : ''),
                        timestamp: typeof n?.timestamp === 'string' && n.timestamp
                            ? n.timestamp
                            : (typeof n?.created_at === 'string' && n.created_at ? n.created_at : new Date().toISOString())
                    };
                });
            }
            catch { return []; }
        }
        
        function saveNotes(notes) {
            localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notes));
            renderNotes();
        }

        function saveDraft(text) {
            localStorage.setItem(NOTES_DRAFT_KEY, text || '');
        }

        function loadDraft() {
            return localStorage.getItem(NOTES_DRAFT_KEY) || '';
        }

        function renderDraftPreview(text) {
            const preview = document.getElementById('noteDraftPreviewContent');
            if (!preview) return;
            const clean = text || '';
            if (!clean.trim()) {
                preview.innerHTML = '<span style="color: var(--text-tertiary);">Type in the note box to preview Markdown rendering in real time.</span>';
                return;
            }
            preview.innerHTML = renderNoteMarkdown(clean);
        }

        function handleNoteInputChange(value) {
            saveDraft(value);
            renderDraftPreview(value);
        }

        function initNoteComposer() {
            const input = document.getElementById('noteInput');
            if (!input) return;
            const draft = loadDraft();
            input.value = draft;
            renderDraftPreview(draft);
            input.addEventListener('input', () => {
                handleNoteInputChange(input.value);
            });
            input.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                    e.preventDefault();
                    addFreeNote();
                }
            });
        }

        function getFocusedNoteId() {
            const value = localStorage.getItem(NOTES_FOCUS_KEY);
            return value ? Number(value) : null;
        }

        function getActiveNoteId() {
            const value = localStorage.getItem(NOTES_ACTIVE_KEY);
            return value ? Number(value) : null;
        }

        function setFocusedNoteId(id) {
            if (!id) localStorage.removeItem(NOTES_FOCUS_KEY);
            else localStorage.setItem(NOTES_FOCUS_KEY, String(id));
        }

        function setActiveNoteId(id) {
            if (!id) localStorage.removeItem(NOTES_ACTIVE_KEY);
            else localStorage.setItem(NOTES_ACTIVE_KEY, String(id));
        }

        function toggleFocusNote(id, e) {
            e?.stopPropagation();
            const focusedId = getFocusedNoteId();
            setFocusedNoteId(focusedId === id ? null : id);
            renderNotes();
        }

        function openNote(id) {
            setActiveNoteId(id);
            renderNotes();
            switchSidebarTab('notes');
        }

        function ensureNoteReader() {
            const panel = document.getElementById('panel-notes');
            const notesList = document.getElementById('notesList');
            if (!panel || !notesList) return null;
            notesList.style.maxHeight = '32vh';

            let reader = document.getElementById('noteReader');
            if (!reader) {
                reader = document.createElement('div');
                reader.id = 'noteReader';
                reader.className = 'note-reader';
                notesList.insertAdjacentElement('afterend', reader);
            }
            return reader;
        }

        function renderNoteMarkdown(text) {
            return escapeHtml(text || '')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }

        function renderNoteReader(notes) {
            const reader = ensureNoteReader();
            if (!reader) return;
            if (notes.length === 0) {
                reader.innerHTML = '<div class="reader-title">Reader</div><div class="reader-content">No notes yet.</div>';
                return;
            }

            let activeId = getActiveNoteId();
            let active = notes.find(n => n.id === activeId);
            if (!active) {
                active = notes[0];
                setActiveNoteId(active.id);
            }
            const time = new Date(active.timestamp).toLocaleString();
            const citationHtml = active.citation ? `<div class="note-citation">${escapeHtml(active.citation)}</div>` : '';
            const activeBody = typeof active.body === 'string' ? active.body : '';
            reader.innerHTML = `
                <div class="reader-title">Reading • ${escapeHtml(active.section || 'General')} • ${time}</div>
                ${citationHtml}
                <div class="reader-content">${renderNoteMarkdown(activeBody)}</div>
            `;
        }
        
        function addNote(citation, body, section) {
            const notes = loadNotes();
            const note = {
                id: Date.now(),
                citation: citation || '',
                body: body || '',
                section: section || '',
                timestamp: new Date().toISOString()
            };
            notes.push(note);
            setActiveNoteId(note.id);
            saveNotes(notes);
            // Switch to notes tab
            switchSidebarTab('notes');
        }
        
        function addFreeNote() {
            const input = document.getElementById('noteInput');
            const text = input.value.trim();
            if (!text) return;
            addNote('', text, '');
            input.value = '';
            saveDraft('');
            renderDraftPreview('');
        }
        
        function deleteNote(id, e) {
            e?.stopPropagation();
            const notes = loadNotes().filter(n => n.id !== id);
            if (getFocusedNoteId() === id) setFocusedNoteId(null);
            if (getActiveNoteId() === id) setActiveNoteId(notes.length ? notes[0].id : null);
            saveNotes(notes);
        }
        
        function renderNotes() {
            const notes = loadNotes();
            const container = document.getElementById('notesList');
            const counter = document.getElementById('notesCount');
            if (!container) return;
            
            counter.textContent = notes.length + ' note' + (notes.length !== 1 ? 's' : '');
            
            if (notes.length === 0) {
                container.innerHTML = '<p style="font-size:0.85rem; color:var(--text-tertiary); text-align:center; padding:2rem 0;">Select text and click "Add Note" to begin, or write freely below.</p>';
                renderNoteReader(notes);
                return;
            }

            const focusedId = getFocusedNoteId();
            const activeId = getActiveNoteId();
            const sortedNotes = [...notes].sort((a, b) => {
                const aFocused = a.id === focusedId ? 1 : 0;
                const bFocused = b.id === focusedId ? 1 : 0;
                if (aFocused !== bFocused) return bFocused - aFocused;
                return new Date(b.timestamp) - new Date(a.timestamp);
            });

            container.innerHTML = sortedNotes.map(n => {
                const time = new Date(n.timestamp).toLocaleString();
                const citationHtml = n.citation 
                    ? `<div class="note-citation">${escapeHtml(n.citation)}</div>` 
                    : '';
                const noteBody = typeof n.body === 'string' ? n.body : '';
                const preview = noteBody.length > 140 ? (noteBody.slice(0, 140) + '...') : noteBody;
                const focusLabel = n.id === focusedId ? 'Unfocus' : 'Focus';
                return `<div class="note-card ${n.id === activeId ? 'active' : ''} ${n.id === focusedId ? 'focused' : ''}" onclick="openNote(${n.id})">
                    ${citationHtml}
                    <div class="note-body">${escapeHtml(preview)}</div>
                    <div class="note-meta">
                        <span>${n.section ? escapeHtml(n.section) : ''} ${time}</span>
                        <span>
                            <button class="note-focus" onclick="toggleFocusNote(${n.id}, event)">${focusLabel}</button>
                            <button class="note-delete" onclick="deleteNote(${n.id}, event)">Delete</button>
                        </span>
                    </div>
                </div>`;
            }).join('');
            renderNoteReader(sortedNotes);
        }
        
        function exportNotesToObsidian() {
            const notes = loadNotes();
            if (notes.length === 0) { alert('No notes to export.'); return; }
            
            const title = document.title.replace(' - Interactive Learning', '');
            const sourceFile = document.querySelector('.main-content header p')?.textContent?.match(/Source: (.+)/)?.[1] || '';
            
            let md = `---
tags: [lecture-notes, mfin7034]
source: "${sourceFile}"
date: ${new Date().toISOString().split('T')[0]}
---

`;
            md += `# ${title}

`;
            md += `> [!info] Source
> PDF: [[${sourceFile.replace('.pdf','')}]]

`;
            
            notes.forEach((n, idx) => {
                if (n.citation) {
                    md += `> [!quote] Highlight
> ${n.citation}

`;
                }
                const noteBody = typeof n.body === 'string' ? n.body : '';
                md += noteBody + `

`;
                if (idx < notes.length - 1) md += `---

`;
            });
            
            md += `
## References

- Source: ${sourceFile}
- Generated: ${new Date().toLocaleString()}
`;
            
            const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = title.replace(/[^a-zA-Z0-9一-鿿 ]/g, '_') + '.md';
            a.click();
            URL.revokeObjectURL(a.href);
        }
        
        // ── Text Highlight & Selection ──
        const highlightTooltip = document.createElement('div');
        highlightTooltip.className = 'highlight-tooltip';
        highlightTooltip.innerHTML = `
            <button onclick="highlightSelection()">Highlight</button>
            <button onclick="highlightAndNote()">+ Note</button>
        `;
        document.body.appendChild(highlightTooltip);
        
        document.addEventListener('mouseup', (e) => {
            const sel = window.getSelection();
            const text = sel.toString().trim();
            
            // Only show for selections within main content
            const main = document.querySelector('.main-content');
            if (!text || text.length < 3 || !main?.contains(sel.anchorNode)) {
                highlightTooltip.classList.remove('show');
                return;
            }
            
            const range = sel.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            highlightTooltip.style.left = rect.left + (rect.width / 2) - 60 + 'px';
            highlightTooltip.style.top = rect.top - 40 + window.scrollY + 'px';
            highlightTooltip.classList.add('show');
        });
        
        document.addEventListener('mousedown', (e) => {
            if (!highlightTooltip.contains(e.target)) {
                highlightTooltip.classList.remove('show');
            }
        });
        
        function highlightSelection() {
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const range = sel.getRangeAt(0);
            const mark = document.createElement('mark');
            mark.className = 'text-highlight';
            try {
                range.surroundContents(mark);
            } catch(e) {
                // Cross-element selection: fall back
                const text = sel.toString();
                mark.textContent = text;
                range.deleteContents();
                range.insertNode(mark);
            }
            sel.removeAllRanges();
            highlightTooltip.classList.remove('show');
        }
        
        function highlightAndNote() {
            const sel = window.getSelection();
            const text = sel.toString().trim();
            if (!text) return;
            
            // Find section context
            let section = '';
            let node = sel.anchorNode;
            while (node && node !== document.body) {
                if (node.classList?.contains('concept-section')) {
                    const h2 = node.querySelector('h2');
                    if (h2) section = h2.textContent;
                    break;
                }
                node = node.parentNode;
            }
            
            highlightSelection();
            
            openInlineSelectionNoteEditor(text, section, sel.getRangeAt(0).getBoundingClientRect());
        }
        

        function closeInlineSelectionNoteEditor() {
            document.getElementById('inlineSelectionNoteEditor')?.remove();
        }

        function openInlineSelectionNoteEditor(selectionText, section, rect) {
            closeInlineSelectionNoteEditor();
            const editor = document.createElement('div');
            editor.id = 'inlineSelectionNoteEditor';
            editor.style.position = 'absolute';
            editor.style.zIndex = '10030';
            editor.style.width = 'min(420px, 90vw)';
            editor.style.background = 'var(--bg-card)';
            editor.style.border = '1px solid var(--border-color)';
            editor.style.borderRadius = '12px';
            editor.style.boxShadow = '0 16px 36px rgba(0,0,0,0.32)';
            editor.style.padding = '0.65rem';
            editor.style.top = (window.scrollY + rect.bottom + 10) + 'px';
            editor.style.left = Math.max(12, Math.min(window.scrollX + rect.left, window.scrollX + window.innerWidth - 440)) + 'px';
            editor.innerHTML = `
                <div style="font-size:0.78rem;color:var(--text-tertiary);margin-bottom:0.4rem;">Add note for selection</div>
                <textarea id="inlineSelectionNoteInput" placeholder="Write note... (Markdown supported)" style="width:100%;min-height:88px;background:var(--bg-primary);color:var(--text-primary);border:1px solid var(--border-color);border-radius:8px;padding:0.5rem;font-size:0.86rem;resize:vertical;"></textarea>
                <div style="display:flex;justify-content:flex-end;gap:0.45rem;margin-top:0.45rem;">
                    <button type="button" id="inlineSelectionNoteCancel" style="border:1px solid var(--border-color);background:var(--bg-elevated);color:var(--text-primary);border-radius:8px;padding:0.3rem 0.6rem;cursor:pointer;font-size:0.8rem;">Cancel</button>
                    <button type="button" id="inlineSelectionNoteSave" style="border:1px solid rgba(163,217,165,.55);background:var(--bg-elevated);color:var(--accent-secondary);border-radius:8px;padding:0.3rem 0.6rem;cursor:pointer;font-size:0.8rem;">Save</button>
                </div>
            `;
            document.body.appendChild(editor);
            const input = editor.querySelector('#inlineSelectionNoteInput');
            input?.focus();
            editor.querySelector('#inlineSelectionNoteCancel')?.addEventListener('click', closeInlineSelectionNoteEditor);
            editor.querySelector('#inlineSelectionNoteSave')?.addEventListener('click', () => {
                const body = (input?.value || '').trim() || '(highlighted)';
                addNote(selectionText, body, section);
                closeInlineSelectionNoteEditor();
            });
        }

        // ── Init ──
        document.addEventListener('DOMContentLoaded', () => {
            new LearningPageController();
            
            // Add reveal animation to concept sections
            document.querySelectorAll('.feynman-block, .quiz-container, .expandable, .chart-container, .diagram-container, .comparison-block, .stats-grid').forEach(el => {
                el.classList.add('reveal-on-scroll');
            });
            
            // Re-init observer for dynamically added elements
            const obs = new IntersectionObserver((entries) => {
                entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('revealed'); });
            }, { threshold: 0.08 });
            document.querySelectorAll('.reveal-on-scroll').forEach(el => obs.observe(el));
            
            // Initialize note draft autosave + live markdown preview
            initNoteComposer();
            // Load saved notes
            renderNotes();
        });
        
        // Typing dots animation
        const typingStyle = document.createElement('style');
        typingStyle.textContent = `
            .typing-dots span {
                animation: blink 1.4s infinite;
                font-size: 1.5em;
                line-height: 1;
            }
            .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
            .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
            @keyframes blink {
                0%, 60%, 100% { opacity: 0.2; }
                30% { opacity: 1; }
            }
        `;
        document.head.appendChild(typingStyle);
    
    </script>
    
    <!-- KaTeX auto-render -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "$", right: "$", display: false},
                        {left: "\\(", right: "\\)", display: false},
                        {left: "\\[", right: "\\]", display: true}
                    ],
                    throwOnError: false
                });
            }
        });
    </script>
    <script src="./app-shell.js?v=12"></script>
    <script src="./lecture-enhancements.js?v=8"></script>
</body>
</html>